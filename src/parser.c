/**
 * Copyright (c) 2021 Olle LÃ¶gdahl
 * 
 * This software is released under the MIT License.
 * https://opensource.org/licenses/MIT
 */

#include "parser.h"

#include <stdbool.h>
#include <assert.h>
#include <stdlib.h>

#include "err.h"

bool optimize_assign(toklist_t *tokens, unsigned *ind, asm_info_t *info, FILE *out);
bool optimize_empty(toklist_t *tokens, unsigned *ind, asm_info_t *info, FILE *out);
bool optimize_unreachable(toklist_t *tokens, unsigned *ind, asm_info_t *info, FILE *out);
bool optimize_copy_to(toklist_t *tokens, unsigned *ind, asm_info_t *info, FILE *out);
bool optimize_multiply_to(toklist_t *tokens, unsigned *ind, asm_info_t *info, FILE *out);

bool(*optimizers[])(toklist_t *, unsigned *, asm_info_t *, FILE *) = {
    optimize_assign,
    optimize_empty,
    optimize_unreachable,
    optimize_copy_to,
    optimize_multiply_to
};

#define ASM_INFO(ai, out, ...) if(ai->debug) asm_comment(ai, out, __VA_ARGS__)

void parse_branch(asm_info_t *asm_info, toklist_t *tokens, FILE *out, unsigned offset) {
    assert(tokens->count > 0);

    for(unsigned i = offset; i < tokens->count; ++i) {
        // run all optimizers
        for(unsigned j = 0; j < sizeof optimizers / sizeof optimizers[0]; ++j) {
            if((*optimizers[j])(tokens, &i, asm_info, out)) continue;
        }

        tok_t *tok = tokens->items[i];
        switch (tok->type) {
        case MOV:
            ASM_INFO(asm_info, out, "mov %d", tok->i);
            asm_move(asm_info, out, tok->i);
            break;
        case MOD:
            ASM_INFO(asm_info, out, "inc/dec %d", tok->i);
            asm_diff(asm_info, out, tok->i);
            break;
        case READ:
            ASM_INFO(asm_info, out, "read");
            asm_read(asm_info, out);
            break;
        case WRITE:
            ASM_INFO(asm_info, out, "write");
            asm_write(asm_info, out);
            break;
        case BRANCH:
            ASM_INFO(asm_info, out, "branch %s begin", tok->n);
            asm_branch_begin(asm_info, out, tok->n);
            parse_branch(asm_info, tok->children, out, 0);
            ASM_INFO(asm_info, out, "branch %s end", tok->n);
            asm_branch_end(asm_info, out, tok->n);

            free(tok->n);
            break;
        }
    }
}

void parse(asm_info_t *asm_info, toklist_t *tokens, FILE *out) {
    if(tokens->count == 0) error("no tokens to parse. aborting.");

    asm_comment(asm_info, out, "generated by bfc");

    ASM_INFO(asm_info, out, "header");
    asm_header(asm_info, out);

    // If the first instruction is a branch, always skip it (unreachable).
    unsigned offset = 0;
    if(tokens->items[0]->type == BRANCH) {
        ASM_INFO(asm_info, out, "optimized away unreachable branch");
        offset = 1;
    }

    parse_branch(asm_info, tokens, out, offset);

    ASM_INFO(asm_info, out, "footer");
    asm_footer(asm_info, out);
}


#define TGETC(l, i) l->children->items[i]

#define IS_INC(t) (t->type == MOD && t->i == 1)
#define IS_DEC(t) (t->type == MOD && t->i == -1)
#define IS_MOV(t) (t->type == MOV)
#define IS_MOV_WITH(t, v) (t->type == MOV && t->i == v)

/**
 * [-] is an assign to 0 call.
 */
bool optimize_assign(toklist_t *tokens, unsigned *ind, asm_info_t *info, FILE *out) {
    if(tokens->items[*ind]->type != BRANCH) return false;
    toklist_t *lst = tokens->items[*ind]->children;
    if(lst->count != 1) return false;

    if(lst->items[0]->type == MOD && lst->items[0]->i == -1) {
        ASM_INFO(info, out, "optimized '[-]' into a 0 assignment");
        asm_set(info, out, 0);
        return true;
    }
}

/**
 * [] should be removed
 */
bool optimize_empty(toklist_t *tokens, unsigned *ind, asm_info_t *info, FILE *out) {
    tok_t *root = tokens->items[*ind];
    if(root->type == BRANCH && root->children->count == 0) {
        ASM_INFO(info, out, "optimized away empty branch");
        return true;
    }

    return false;
}

/**
 * [+++>-<][] second parenthesis can be removed.
 * There needs to be some assignment or movement before a new branch.
 */
bool optimize_unreachable(toklist_t *tokens, unsigned *ind, asm_info_t *info, FILE *out) {
    if(*ind == 0) return false;
    tok_t *prev = tokens->items[*ind - 1];
    tok_t *curr = tokens->items[*ind];
    if(prev->type == BRANCH && curr->type == BRANCH) {
        ASM_INFO(info, out, "optimized away unreachable branch");
        return true;
    }

    return false;
}

/**
 * [-a+b] copies all from current cell to +a, and clears current cell in process.
 * 
 * synonyms:
 * [>>>+<<<-]
 * [->>>+<<<]
 */
bool optimize_copy_to(toklist_t *tokens, unsigned *ind, asm_info_t *info, FILE *out) {
    tok_t *root = tokens->items[*ind];
    if(root->type == BRANCH && root->children->count == 4) {
        int move_size = 0;

        tok_t *first = TGETC(root, 0);
        tok_t *second = TGETC(root, 1);
        tok_t *third = TGETC(root, 2);
        tok_t *fourth = TGETC(root, 3);

        if(IS_MOV(first)) {
            move_size = first->i;
            
            if(IS_INC(second) && IS_MOV_WITH(third, -move_size) && IS_DEC(fourth)) {
                ASM_INFO(info, out, "optimized copy to (%d)", move_size);
                asm_copy(info, out, move_size);
                asm_set(info, out, 0);
                return true;
            }
        } else if(IS_MOV(second)) {
            move_size = second->i;

            if(IS_DEC(first) && IS_INC(third) && IS_MOV_WITH(fourth, -move_size)) {
                ASM_INFO(info, out, "optimized copy to (%d)", move_size);
                asm_copy(info, out, move_size);
                asm_set(info, out, 0);
                return true;
            }
        }
    }

    return false;
}

/**
 * a special case of copy to multiple destinations.
 * 
 * synonyms:
 * [->++>>>+>>>>+++<<<<<<<<]
 * [>++>>>+>>>>+++<<<<<<<<-]
 */
bool optimize_multiply_to(toklist_t *tokens, unsigned *ind, asm_info_t *info, FILE *out) {
    tok_t *root = tokens->items[*ind];
    if(root->type == BRANCH) {
        // ensure that the block begin/ends with a decrement
        unsigned start, end, offset;
        if(IS_DEC(TGETC(root, 0))) {
            start = 1;
            end = root->children->count - 1;
        } else if(IS_DEC(TGETC(root, root->children->count - 1))) {
            start = 0;
            end = root->children->count - 2;
        } else return false;

        // ensure there is an odd amount of tokens
        if((end + 1 - start) % 2 == 0) return false;
        unsigned operations = (end - start) / 2;

        // read and store
        int moves_tot = 0;
        int moves[operations];
        int factors[operations];
        
        for(unsigned i = 0; i < operations; ++i) {
            unsigned off = start + i*2;

            tok_t *a = root->children->items[off];
            tok_t *b = root->children->items[off + 1];

            if(a->type != MOV || b->type != MOD) return false;

            moves[i] = a->i;
            factors[i] = b->i;

            moves_tot += a->i;

            // we might have modified the starting cell in a more
            // advanced loop. forbid this.
            if(moves_tot == 0) return false;
        }

        // ensure that the last move placed us at start.
        tok_t *ptr_restore = TGETC(root, end);
        if(!IS_MOV_WITH(ptr_restore, -moves_tot)) return false;

        ASM_INFO(info, out, "optimizing %u multiplications", operations);

        int mov_accum = 0;
        for(int i = 0; i < operations; ++i) {
            mov_accum += moves[i];
            asm_mult(info, out, factors[i], mov_accum);
        }

        asm_set(info, out, 0);
        return true;
    }

    return false;
}