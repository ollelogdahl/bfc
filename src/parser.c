/**
 * Copyright (c) 2021 Olle LÃ¶gdahl
 * 
 * This software is released under the MIT License.
 * https://opensource.org/licenses/MIT
 */

#include "parser.h"

#include <assert.h>

#include "err.h"

void optimize_assign(toklist_t *tokens, unsigned *ind, asm_info_t *info, FILE *out);
void optimize_empty(toklist_t *tokens, unsigned *ind, asm_info_t *info, FILE *out);
void optimize_unreachable(toklist_t *tokens, unsigned *ind, asm_info_t *info, FILE *out);

#define ASM_INFO(ai, out, ...) if(ai->debug) asm_comment(ai, out, __VA_ARGS__)

void parse_branch(asm_info_t *asm_info, toklist_t *tokens, FILE *out, unsigned offset) {
    assert(tokens->count > 0);

    for(unsigned i = offset; i < tokens->count; ++i) {
        // run all optimizers
        optimize_empty(tokens, &i, asm_info, out);
        if(i == tokens->count) break;
        optimize_assign(tokens, &i, asm_info, out);
        if(i == tokens->count) break;
        optimize_unreachable(tokens, &i, asm_info, out);
        if(i == tokens->count) break;

        tok_t *tok = tokens->items[i];
        switch (tok->type) {
        case MOV:
            ASM_INFO(asm_info, out, "mov %d", tok->i);
            asm_move(asm_info, out, tok->i);
            break;
        case MOD:
            ASM_INFO(asm_info, out, "inc/dec %d", tok->i);
            asm_diff(asm_info, out, tok->i);
            break;
        case READ:
            ASM_INFO(asm_info, out, "read");
            asm_read(asm_info, out);
            break;
        case WRITE:
            ASM_INFO(asm_info, out, "write");
            asm_write(asm_info, out);
            break;
        case BRANCH:
            ASM_INFO(asm_info, out, "branch %d begin", tok->n);
            asm_branch_begin(asm_info, out, tok->n);
            parse_branch(asm_info, tok->children, out, 0);
            ASM_INFO(asm_info, out, "branch %d end", tok->n);
            asm_branch_end(asm_info, out, tok->n);
            break;
        }
    }
}

void parse(asm_info_t *asm_info, toklist_t *tokens, FILE *out) {
    if(tokens->count == 0) error("no tokens to parse. aborting.");

    asm_comment(asm_info, out, "generated by bfc");

    ASM_INFO(asm_info, out, "header");
    asm_header(asm_info, out);

    // If the first instruction is a branch, always skip it (unreachable).
    unsigned offset = 0;
    if(tokens->items[0]->type == BRANCH) {
        ASM_INFO(asm_info, out, "optimized away unreachable branch");
        offset = 1;
    }

    parse_branch(asm_info, tokens, out, offset);

    ASM_INFO(asm_info, out, "footer");
    asm_footer(asm_info, out);
}

/**
 * [-] is an assign to 0 call.
 */
void optimize_assign(toklist_t *tokens, unsigned *ind, asm_info_t *info, FILE *out) {
    if(tokens->items[*ind]->type != BRANCH) return;
    toklist_t *lst = tokens->items[*ind]->children;
    if(lst->count != 1) return;

    if(lst->items[0]->type == MOD && lst->items[0]->i == -1) {
        ASM_INFO(info, out, "optimized '[-]' into a 0 assignment");
        asm_set(info, out, 0);
        (*ind)++;
    }
}

/**
 * [] should be removed
 */
void optimize_empty(toklist_t *tokens, unsigned *ind, asm_info_t *info, FILE *out) {
    if(tokens->items[*ind]->type != BRANCH) return;
    if(tokens->items[*ind]->children->count == 0) {
        ASM_INFO(info, out, "optimized away empty branch");
        (*ind)++;
    }
}

/**
 * [+++>-<][] second parenthesis can be removed.
 * There needs to be some assignment or movement before a new branch.
 */
void optimize_unreachable(toklist_t *tokens, unsigned *ind, asm_info_t *info, FILE *out) {
    if(*ind == 0) return;
    tok_t *prev = tokens->items[*ind - 1];
    tok_t *curr = tokens->items[*ind];
    if(prev->type == BRANCH && curr->type == BRANCH) {
        ASM_INFO(info, out, "optimized away unreachable branch");
        (*ind)++;
    }
}